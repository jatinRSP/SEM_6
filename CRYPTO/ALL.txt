EXTENDED EUCLID /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

int extendedEuclidean(int a, int b)
{
    int t1 = 0, t2 = 1, q, r, t;
    while (b != 0)
    {
        q = a / b;
        r = a % b;
        t = t1 - t2 * q;
        t1 = t2;
        t2 = t;
        a = b;
        b = r;
    }

    return a != 1 ? 0 : t1;
}

int main()
{
    int a, b, result;

    printf("Inverse of: ");
    scanf("%d", &a);

    printf("With modulo: ");
    scanf("%d", &b);

    result = extendedEuclidean(b, a);

    if (result == 0)
    {
        printf("Inverse does not exist\n");
        return 0;
    }

    else if (result < 0)
    {
        result += b;
    }

    printf("Inverse: %d\n", result);

    return 0;
}


RSA /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <math.h>

int isPrime(int n)
{
    int i;
    for (i = 2; i < sqrt(n); i++)
    {
        if (n % i == 0)
        {
            return 0;
        }
    }
    return 1;
}

int gcd(int a, int b)
{
    if (b == 0)
    {
        return a;
    }

    return gcd(b, a % b);
}

int extendedEuclidean(int a, int b)
{
    int t1 = 0, t2 = 1, q, r, t;
    while (b != 0)
    {
        q = a / b;
        r = a % b;
        t = t1 - t2 * q;
        t1 = t2;
        t2 = t;
        a = b;
        b = r;
    }

    return a != 1 ? 0 : t1;
}

int fastExponentiation(int a, int b, int n)
{
    int bitCount = (int)ceil(log2(b)); // Cast log2 result to int

    int aBinary[bitCount];
    int modValues[bitCount];

    int i;
    int result = 1; // Initialize result to 1

    for (i = bitCount - 1; i >= 0; i--)
    {
        aBinary[i] = b % 2;
        b = b / 2;
    }

    for (i = bitCount - 1; i >= 0; i--)
    {
        if (i == bitCount - 1) // Change i == 0 to i == bitCount - 1
        {
            modValues[i] = a % n;
        }
        else
        {
            modValues[i] = (modValues[i + 1] * modValues[i + 1]) % n; // Change i - 1 to i + 1
        }
    }

    for (i = 0; i < bitCount; i++)
    {
        if (aBinary[i] == 1)
        {
            result = (result * modValues[i]) % n; // Add modulo operation here
        }
    }
    return result;
}

int main()
{

    int p, q, e, d, n, phi;

    int m, c;

    printf("Enter the value of p: ");
    scanf("%d", &p);

    if (isPrime(p) == 0)
    {
        printf("p is not prime\n");
        return 0;
    }

    printf("Enter the value of q: ");
    scanf("%d", &q);

    if (isPrime(q) == 0)
    {
        printf("q is not prime\n");
        return 0;
    }

    n = p * q;

    phi = (p - 1) * (q - 1);

    printf("Enter the value of e between 1 and %d: ", phi);
    scanf("%d", &e);

    if (e < 1 || e > phi)
    {
        printf("Invalid value of e\n");
        return 0;
    }

    if (gcd(e, phi) != 1)
    {
        printf("Invalid value of e\n");
        return 0;
    }

    d = extendedEuclidean(phi, e);

    if (d < 0)
    {
        d += phi;
    }

    printf("Public key: (%d, %d)\n", e, n);
    printf("Private key: (%d, %d)\n", d, n);

    printf("Enter the message: ");
    scanf("%d", &m);

    c = fastExponentiation(m, e, n);

    printf("Encrypted message: %d\n", c);

    m = fastExponentiation(c, d, n);

    printf("Decrypted message: %d\n", m);

    return 0;
}


Fast EXPONENTIAL /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

// Function to perform modular exponentiation (a^b % m) using iterative approach
long long modularExponentiation(long long a, long long b, long long m)
{
    long long result = 1;
    a = a % m; // Take modulo of base if a >= m

    while (b > 0)
    {
        // If b is odd, multiply base with result
        if (b & 1 == 1)
        {
            result = (result * a) % m;
        }

        // Right shift exponent by 1 and square the base
        a = (a * a) % m;
        b = b >> 1; // Divide exponent by 2
    }

    return result;
}

int main()
{
    long long a, b, m;
    printf("Enter base (a): ");
    scanf("%lld", &a);
    printf("Enter exponent (b): ");
    scanf("%lld", &b);
    printf("Enter modulo (m): ");
    scanf("%lld", &m);

    // Compute a^b % m using modular exponentiation
    long long result = modularExponentiation(a, b, m);

    // Display the result
    printf("%lld^%lld mod %lld = %lld\n", a, b, m, result);

    return 0;
}


cca2 RSA /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CCA2 attak on RSA

#include <stdio.h>
#include <math.h>

int isPrime(int n)
{
    int i;
    for (i = 2; i < sqrt(n); i++)
    {
        if (n % i == 0)
        {
            return 0;
        }
    }
    return 1;
}

int gcd(int a, int b)
{
    if (b == 0)
    {
        return a;
    }

    return gcd(b, a % b);
}

int extendedEuclidean(int a, int b)
{
    int t1 = 0, t2 = 1, q, r, t;
    while (b != 0)
    {
        q = a / b;
        r = a % b;
        t = t1 - t2 * q;
        t1 = t2;
        t2 = t;
        a = b;
        b = r;
    }

    return a != 1 ? 0 : t1;
}

int fastExponentiation(int a, int b, int n)
{
    int bitCount = (int)ceil(log2(b)); // Cast log2 result to int

    int aBinary[bitCount];
    int modValues[bitCount];

    int i;
    int result = 1; // Initialize result to 1

    for (i = bitCount - 1; i >= 0; i--)
    {
        aBinary[i] = b % 2;
        b = b / 2;
    }

    for (i = bitCount - 1; i >= 0; i--)
    {
        if (i == bitCount - 1) // Change i == 0 to i == bitCount - 1
        {
            modValues[i] = a % n;
        }
        else
        {
            modValues[i] = (modValues[i + 1] * modValues[i + 1]) % n; // Change i - 1 to i + 1
        }
    }

    for (i = 0; i < bitCount; i++)
    {
        if (aBinary[i] == 1)
        {
            result = (result * modValues[i]) % n; // Add modulo operation here
        }
    }
    return result;
}

int main()
{

    int p, q, e, d, n, phi;

    int m, c;

    int m1, c1, decOfC1, mDec;

    printf("\n-----------------CHALLENGER WILL COMPUTE CIPHER TEXT-----------------\n\n");

    do
    {
        printf("Enter the value of p: ");
        scanf("%d", &p);
    } while (!isPrime(p));

    do
    {
        printf("Enter the value of q: ");
        scanf("%d", &q);
    } while (!isPrime(q));

    n = p * q;

    printf("\nValue of n: %d\n", n);

    phi = (p - 1) * (q - 1);

    printf("Value of phi: %d\n", phi);

    do
    {
        printf("\nEnter the value of e between 1 and %d: ", phi);
        scanf("%d", &e);
    } while (e < 1 || e > phi || gcd(e, phi) != 1);

    d = extendedEuclidean(phi, e);

    if (d < 0)
    {
        d += phi;
    }

    printf("Value of d: %d\n", d);

    printf("\nPublic key: (%d, %d)\n", e, n);
    printf("Private key: (%d, %d)\n", d, n);

    printf("\nEnter the message: ");
    scanf("%d", &m);

    c = fastExponentiation(m, e, n);

    printf("Encrypted message: %d\n", c);

    printf("\n\n-----------------CHALLENGER WILL GIVE %d TO ADVERSARY-----------------\n\n", c);

    printf("\n-----------------ADVERSARY WILL CHOOSE M1-----------------\n\n");

    printf("Enter the message: ");
    scanf("%d", &m1);
    printf("\n");

    printf("\n-----------------C1 = C*M1^e mod n-----------------\n\n");

    c1 = (c * fastExponentiation(m1, e, n)) % n;

    printf("Encrypted message: %d\n", c1);

    printf("\n\n-----------------ADVERSARY WILL QUERY DECRYPTION OF %d-----------------\n\n", c1);

    decOfC1 = fastExponentiation(c1, d, n);

    printf("Decrypted message: %d\n", decOfC1);

    printf("\n\n-----------------ADVERSARY COMPUTES M1 INVERSE WITH RESPECT TO N-----------------\n\n");

    int m1Inverse = extendedEuclidean(n, m1);

    if (m1Inverse < 0)
    {
        m1Inverse += n;
    }

    printf("M1 inverse: %d\n", m1Inverse);

    printf("\n\n-----------------ADVERSARY WILL COMPUTE M = C1*M1^-1 mod n-----------------\n\n");

    mDec = (decOfC1 * m1Inverse) % n;

    printf("Decrypted message: %d\n\n", mDec);

    if (mDec == m)
    {
        printf("Adversary has successfully decrypted the message\n");
    }
    else
    {
        printf("Adversary has failed to decrypt the message\n");
    }

    return 0;
}


Elgamal /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <math.h>

// int fast_exp(int a, int b, int n)
// {
//     int y = 1;
//     while (b > 0)
//     {
//         if (b % 2 == 0)
//         {
//             a = (a * a) % n;
//             b = b / 2;
//         }
//         else
//         {
//             y = (a * y) % n;
//             b = b - 1;
//         }
//     }
//     return y;
// }

int extendedEuclidean(int a, int b)
{
    int t1 = 0, t2 = 1, q, r, t;
    while (b != 0)
    {
        q = a / b;
        r = a % b;
        t = t1 - t2 * q;
        t1 = t2;
        t2 = t;
        a = b;
        b = r;
    }

    return a != 1 ? 0 : t1;
}

int fastExponentiation(int a, int b, int n)
{
    int bitCount = (int)ceil(log2(b)); // Cast log2 result to int

    int aBinary[bitCount];
    int modValues[bitCount];

    int i;
    int result = 1; // Initialize result to 1

    for (i = bitCount - 1; i >= 0; i--)
    {
        aBinary[i] = b % 2;
        b = b / 2;
    }

    for (i = bitCount - 1; i >= 0; i--)
    {
        if (i == bitCount - 1) // Change i == 0 to i == bitCount - 1
        {
            modValues[i] = a % n;
        }
        else
        {
            modValues[i] = (modValues[i + 1] * modValues[i + 1]) % n; // Change i - 1 to i + 1
        }
    }

    for (i = 0; i < bitCount; i++)
    {
        if (aBinary[i] == 1)
        {
            result = (result * modValues[i]) % n; // Add modulo operation here
        }
    }
    return result;
}

void main()
{
    int p, g, x, y;
    int m, r, c1, c2, dec_m;

    printf("Enter the value of p: ");
    scanf("%d", &p);

    printf("Enter the value of g: ");
    scanf("%d", &g);

    printf("\nEnter the private key x such that 1 < x < p-1: ");
    scanf("%d", &x);

    y = (int)pow(g, x) % p;

    printf("\nThe public key is: %d %d %d \n", p, g, y);
    printf("The private key is: %d %d %d \n", p, g, x);

    printf("\nEnter the message m: ");
    scanf("%d", &m);

    printf("\nEnter random number r such that 1 < r < p-1: ");
    scanf("%d", &r);

    c1 = fastExponentiation(g, r, p);
    c2 = fastExponentiation(y, r, p) * m % p;

    printf("\nThe cipher text is: %d %d \n", c1, c2);

    int c1inv = extendedEuclidean(p, (fastExponentiation(c1, x, p) % p));

    dec_m = (c2 * c1inv) % p;

    printf("\nThe decrypted message is: %d \n", dec_m);
}

Elgamal Digital Sign /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <math.h>

int fastExponentiation(int a, int b, int n)
{
    int result = 1;
    a = a % n;
    while (b > 0)
    {
        if (b % 2 == 1)
        {
            result = (result * a) % n;
        }
        b = b / 2;
        a = (a * a) % n;
    }
    return result;
}

int gcd(int a, int b)
{
    if (b == 0)
    {
        return a;
    }

    return gcd(b, a % b);
}

int hashFunction(int m, int p)
{
    return m * m % (p - 1);
}

int randomK(int p)
{
    for (int i = 2; i < p - 1; i++)
    {
        if (gcd(i, p - 1) == 1)
        {
            return i;
        }
    }
}

int inverse(int a, int b)
{
    for (int i = 1; i < b; i++)
    {
        if ((a * i) % b == 1)
        {
            return i;
        }
    }
}

void main()
{
    int p, g, x, y;
    int m, hash, k, s1, s2, kInv;
    int v1, v2;

    printf("-----------------SENDER SIDE-----------------\n\n");

    printf("Enter the value of p: ");
    scanf("%d", &p);

    printf("Enter the value of g: ");
    scanf("%d", &g);

    printf("\nEnter the private key x such that 1 < x < p-1: ");
    scanf("%d", &x);

    y = fastExponentiation(g, x, p);

    printf("\nThe public key is: %d %d %d \n", p, g, y);
    printf("The private key is: %d %d %d \n", p, g, x);

    printf("\nEnter the message m: ");
    scanf("%d", &m);

    hash = hashFunction(m, p);

    k = randomK(p);

    printf("The hash value is: %d\n", hash);
    printf("The random number k is: %d\n", k);

    kInv = inverse(k, p - 1);

    printf("The inverse of k is: %d\n", kInv);

    s1 = fastExponentiation(g, k, p);
    s2 = (hash - x * s1) * kInv % (p - 1); // Corrected calculation of s2

    printf("The signature is: %d %d\n", s1, s2);

    printf("\n\n-----------------RECEIVER SIDE-----------------\n\n");

    v1 = (fastExponentiation(y, s1, p) * fastExponentiation(s1, s2, p)) % p;
    v2 = fastExponentiation(g, hash, p);

    printf("v1: %d\n", v1);
    printf("v2: %d\n", v2);

    if (v1 == v2)
    {
        printf("The signature is verified\n");
    }
    else
    {
        printf("The signature is not verified\n");
    }
}

Random num generate /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

unsigned long long int custom_rand(unsigned long long int seed)
{
    unsigned long long int multiplier = 6364136223846793005ULL;
    unsigned long long int increment = 1442695040888963407ULL;
    unsigned long long int modulus = 18446744073709551615ULL; // 2^64 - 1 (64-bit unsigned integer max value)

    // Calculate the next pseudo-random number using LCG algorithm
    seed = (multiplier * seed + increment) % modulus;

    return seed;
}

int main()
{
    unsigned long long int seed = 12345; // Initial seed value
    int i;

    int range_min = 0;
    int range_max = 100;

    // Use current time as seed for better randomness
    time_t t;
    time(&t);
    seed = t;

    // Generate and print 10 pseudo-random numbers within the specified range
    for (i = 0; i < 10; i++)
    {
        // Generate next pseudo-random number
        seed = custom_rand(seed);
        // map to the specified range
        printf("%d\n", range_min + (seed % (range_max - range_min + 1)));
    }

    return 0;
}

Shamir secret sharing /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

int random_number(long x, long a, long c, int m)
{
    // Calculate the next pseudo-random number using Linear Congruential Generator (LCG) algorithm
    long result = (x * a + c) % m;
    int res = (int)result;
    return res;
}

int main()
{

    int S, n, k;
    printf("Enter Secret (S): ");
    scanf("%d", &S);
    printf("Enter Number Of Partitions(n): ");
    scanf("%d", &n);
    printf("Enter number of points(k): ");
    scanf("%d", &k);

    // Generate a random polynomial of degree (k-1) with coefficients from LCG algorithm
    int polynomial[k];
    polynomial[0] = S;
    for (int i = 1; i < k; i++)
    {
        polynomial[i] = random_number(time(0), 17, time(0) + 3, 967);
    }

    // Generate random points on the polynomial
    int points[n][2];
    for (int i = 1; i < n + 1; i++)
    {
        points[i - 1][0] = i;
        int sum = 0;
        for (int j = 0; j < k; j++)
        {
            sum += pow(points[i - 1][0], j) * polynomial[j];
        }
        points[i - 1][1] = sum;
    }

    // Copy random points for Lagrange interpolation
    int random_points[k][2];
    for (int i = 0; i < k; i++)
    {
        random_points[i][0] = points[i][0];
        random_points[i][1] = points[i][1];
    }

    // Lagrange Interpolation (for finding S, the term without any polynomial)
    double l[k];
    int found_Secret = 0;
    for (int i = 0; i < k; i++)
    {
        l[i] = 1.0;
        for (int j = 0; j < k; j++)
        {
            if (j != i)
            {
                // Calculate the Lagrange interpolation coefficients
                l[i] *= (double)-1 * (random_points[j][0]) / (random_points[i][0] - random_points[j][0]);
            }
        }
        // Calculate the secret by summing up the Lagrange coefficients multiplied by the y-values of the points
        found_Secret += (int)(l[i]) * random_points[i][1];
    }

    printf("\nSecret Found: %d\n", found_Secret);
    return 0;
}